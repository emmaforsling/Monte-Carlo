diff --git a/CornellBox/include/Camera.h b/CornellBox/include/Camera.h
index 8c22c57..b3f8d83 100644
--- a/CornellBox/include/Camera.h
+++ b/CornellBox/include/Camera.h
@@ -15,11 +15,11 @@ public:
 	Camera();
 	Camera(Wall* _room, float _eyeDistance, int _raysPerPixel);
 	~Camera();
-	void renderImage(Object** _objects, Light* _light);		// Loops over all pixels and computes
-												// their values.
-	void mappingFunction();						// Converts radiometric values into
-												// photometric ones.
-	void saveImage();							// Alternatively displayImage()
+	void renderImage(Object** _objects, Light* _light);		// - Loops over all pixels and computes
+															//   their values.
+	void mappingFunction();									// - Converts radiometric values into
+															//   photometric ones.
+	void saveImage();										// - Alternatively displayImage()
 
 private:
 	glm::vec3 position;
diff --git a/CornellBox/include/Cube.h b/CornellBox/include/Cube.h
index 163e57f..ef6f218 100644
--- a/CornellBox/include/Cube.h
+++ b/CornellBox/include/Cube.h
@@ -16,7 +16,7 @@ public:
 												// (1,0,0), (0,1,0) etc. and multiplies
 												// them by size (float) and adds the
 												// position (glm::vec3)
-	virtual void calculateChildRays(glm::vec3 _intersectionPoint);
+	virtual void calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint);
 	virtual glm::vec3 calculateIntersection(Ray* _ray);
 	virtual float getRefractiveIndex();
 	virtual glm::vec3 getIntersectedNormal();
diff --git a/CornellBox/include/Object.h b/CornellBox/include/Object.h
index c61a349..8b8b3a2 100644
--- a/CornellBox/include/Object.h
+++ b/CornellBox/include/Object.h
@@ -11,7 +11,7 @@ public:
 	Object(glm::vec3 _position);
 	~Object();
 	virtual glm::vec3 calculateIntersection(Ray* _ray) = 0;
-	virtual void calculateChildRays(glm::vec3 _intersectionPoint) = 0;
+	virtual void calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint) = 0;
 	virtual float getRefractiveIndex() = 0;
 	virtual glm::vec3 getIntersectedNormal() = 0;
 protected:
diff --git a/CornellBox/include/Sphere.h b/CornellBox/include/Sphere.h
index 07ed28c..6618fae 100644
--- a/CornellBox/include/Sphere.h
+++ b/CornellBox/include/Sphere.h
@@ -12,7 +12,7 @@ public:
 	Sphere(glm::vec3 _position, float _radius, bool _transparent, float _refractiveIndex);
 	~Sphere();
 	virtual glm::vec3 calculateIntersection(Ray* _ray);
-	virtual void calculateChildRays(glm::vec3 _intersectionPoint);
+	virtual void calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint);
 	virtual float getRefractiveIndex();
 	virtual glm::vec3 getIntersectedNormal();
 	void setIntersectedNormal(glm::vec3 _intersectedNormal);
diff --git a/CornellBox/include/Wall.h b/CornellBox/include/Wall.h
index aa7993f..3fcb933 100644
--- a/CornellBox/include/Wall.h
+++ b/CornellBox/include/Wall.h
@@ -13,12 +13,12 @@ public:
 	Wall();
 	Wall(glm::vec3 _position, float _size);
 	~Wall();
-	void initializeRectangles();				// sets corners of rectangles to (0,0,0),
-												// (1,0,0), (0,1,0) etc. and multiplies
-												// them by size (float) and adds the
-												// position (glm::vec3)
-	virtual void calculateChildRays(glm::vec3 _intersectionPoint);
-	virtual glm::vec3 calculateIntersection(Ray* _ray);			// either one intersection or none (ray leaving)
+	void initializeRectangles();							// sets corners of rectangles to (0,0,0),
+															// (1,0,0), (0,1,0) etc. and multiplies
+															// them by size (float) and adds the
+															// position (glm::vec3)
+	virtual void calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint);
+	virtual glm::vec3 calculateIntersection(Ray* _ray);		// either one intersection or none (ray leaving)
 	virtual float getRefractiveIndex();
 	virtual glm::vec3 getIntersectedNormal();
 	
diff --git a/CornellBox/src/Cube.cpp b/CornellBox/src/Cube.cpp
index 796d7dd..259fcea 100644
--- a/CornellBox/src/Cube.cpp
+++ b/CornellBox/src/Cube.cpp
@@ -203,8 +203,8 @@ glm::vec3 Cube::calculateIntersection(Ray* _ray)
 	}
 	if(side != 666)
 	{
-		std::cout << "The side for the final intersection point is " << side << std::endl;
-		std::cout << "The normal is " << sides[side]->getNormal().x << ", " << sides[side]->getNormal().y << ", " << sides[side]->getNormal().z << std::endl;
+		//std::cout << "The side for the final intersection point is " << side << std::endl;
+		//std::cout << "The normal is " << sides[side]->getNormal().x << ", " << sides[side]->getNormal().y << ", " << sides[side]->getNormal().z << std::endl;
 		intersectedNormal = sides[side]->getNormal();
 	}
 		
@@ -248,7 +248,16 @@ float Cube::getRefractiveIndex()
 	return refractiveIndex;
 }			
 
-void Cube::calculateChildRays(glm::vec3 _intersectionPoint)
+void Cube::calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint)				// TEMPORARY
 {
-	//TODO: Write code
+	std::cout << "\nCalculating child ray for intersection point " << intersectionPoint.x << ", " << intersectionPoint.y << ", " << intersectionPoint.z << std::endl << std::endl;
+	// calculate direction for reflected or transmitted ray - WHITTED - (TEMPORARY)
+	std::cout << "====== Reflection/refraction =====" << std::endl;
+	glm::vec3 reflectedRayDirection = glm::reflect(_ray->getDirection(), intersectedNormal);
+	std::cout << "reflection = (" << reflectedRayDirection.x << ", " << reflectedRayDirection.y << ", " << reflectedRayDirection.z << ")" << std::endl;
+
+	glm::vec3 refractedRayDirection = glm::refract(_ray->getDirection(), intersectedNormal, refractiveIndex);
+	std::cout << "refraction = (" << refractedRayDirection.x << ", " << refractedRayDirection.y << ", " << refractedRayDirection.z << ")" << std::endl;
+
+	_ray->childNodes = new Ray(intersectionPoint, reflectedRayDirection, _ray->getImportance(), glm::vec3(0.0, 0.0, 0.0), false);
 }
diff --git a/CornellBox/src/Pixel.cpp b/CornellBox/src/Pixel.cpp
index 5ccd16a..48d1d7c 100644
--- a/CornellBox/src/Pixel.cpp
+++ b/CornellBox/src/Pixel.cpp
@@ -79,7 +79,7 @@ void Pixel::shootRays(glm::vec3 _cameraPosition, int _raysPerPixel, glm::vec3 _p
 		glm::vec3 finalIntersection = glm::vec3(0.0, 0.0, 0.0);
 		int closestIntersectedObjectIndex = 666;
 		int numberOfObjects = 4;								// Temporary...
-		int numberOfIterations = 10;
+		int numberOfIterations = 5;
 		int iteration = 0;
 		for(Ray* currentChildRay = rays[i]; currentChildRay != nullptr && iteration <= numberOfIterations; currentChildRay = currentChildRay->childNodes, iteration++)
 		{
@@ -120,39 +120,27 @@ void Pixel::shootRays(glm::vec3 _cameraPosition, int _raysPerPixel, glm::vec3 _p
 				Ray* shadowRay = new Ray(randomPositionOnLightSource, (finalIntersection - randomPositionOnLightSource), 1.0, glm::vec3(0.0, 0.0, 0.0), false);
 				// looping through all objects to check for occlusion
 				glm::vec3 shadowIntersection;
-				std::cout << "\n ====== Checking for occlusion ===== \n" << std::endl;
+				std::cout << "\n= Checking for occlusion. p = (" << finalIntersection.x << ", " << finalIntersection.y << ", " << finalIntersection.z << "), l = (" << randomPositionOnLightSource.x << ", " << randomPositionOnLightSource.y << ", " << randomPositionOnLightSource.z << ") =\n" << std::endl;
 				for(int j = 0; j < numberOfObjects; j++)
 				{
 					shadowIntersection = _objects[j]->calculateIntersection(shadowRay);
 					// std::cout << "objects[" << j << "]->calculateIntersection(shadowRay) returned: (" << shadowIntersection.x << ", " << shadowIntersection.y << ", " << shadowIntersection.z << ")" << std::endl;
 					if( shadowIntersection != glm::vec3(0.0, 0.0, 0.0) )
 					{	
-						std::cout << "Found intersection along shadowRay direction!" << std::endl;
-						if( glm::length(randomPositionOnLightSource - shadowIntersection) < glm::length(randomPositionOnLightSource - finalIntersection) )
+						//std::cout << "Found intersection along shadowRay direction!" << std::endl;
+						if( glm::length(randomPositionOnLightSource - shadowIntersection) != 0 && glm::length(randomPositionOnLightSource - shadowIntersection) < glm::length(randomPositionOnLightSource - finalIntersection) )
 						{
 							intersectionPointVisibleFromLightSource = 0;
-							std::cout << "This intersection point " << "(" << shadowIntersection.x << ", " << shadowIntersection.y << ", " << shadowIntersection.z << ") is closer to the light source than the surface point is - occlusion!" << std::endl;
+							std::cout << "Intersection point " << "(" << shadowIntersection.x << ", " << shadowIntersection.y << ", " << shadowIntersection.z << ") closer to the light source - occlusion!" << std::endl;
 						}
 						else
 						{
-							std::cout << "This intersection point " << "(" << shadowIntersection.x << ", " << shadowIntersection.y << ", " << shadowIntersection.z << ") is not closer to the light source than the surface point is - no occlusion!" << std::endl;
+							std::cout << "Intersection point " << "(" << shadowIntersection.x << ", " << shadowIntersection.y << ", " << shadowIntersection.z << ") not closer to the light source - no occlusion!" << std::endl;
 						}
 					}
 				}
-				// std::cout << "Calculating child rays for intersection point " << finalIntersection.x << ", " << finalIntersection.y << ", " << finalIntersection.z << std::endl;
-				
-				// calculate direction for reflected or transmitted ray - WHITTED - (TEMPORARY)
-				std::cout << "\n ====== Reflection/refraction ===== \n" << std::endl;
-				glm::vec3 reflectedRay = glm::reflect(currentChildRay->getDirection(), _objects[closestIntersectedObjectIndex]->getIntersectedNormal());
-				std::cout << "reflection = (" << reflectedRay.x << ", " << reflectedRay.y << ", " << reflectedRay.z << ")" << std::endl;
-
-				glm::vec3 refractedRay = glm::refract( currentChildRay->getDirection(), _objects[closestIntersectedObjectIndex]->getIntersectedNormal(), _objects[closestIntersectedObjectIndex]->getRefractiveIndex() );
-				std::cout << "refraction = (" << refractedRay.x << ", " << refractedRay.y << ", " << refractedRay.z << ")" << std::endl;
-
-				currentChildRay->childNodes = new Ray(finalIntersection, reflectedRay, currentChildRay->getImportance(), glm::vec3(0.0, 0.0, 0.0), false);
-
-				// _objects[closestIntersectedObjectIndex]->calculateChildRays(finalIntersection);
-
+				// calculating child rays
+				_objects[closestIntersectedObjectIndex]->calculateChildRays(currentChildRay, finalIntersection);
 			}
 		}
 	}
diff --git a/CornellBox/src/Sphere.cpp b/CornellBox/src/Sphere.cpp
index e3a5985..79ab9ae 100644
--- a/CornellBox/src/Sphere.cpp
+++ b/CornellBox/src/Sphere.cpp
@@ -142,10 +142,18 @@ glm::vec3 Sphere::calculateIntersection(Ray* _ray)
 	}
 }
 
-void Sphere::calculateChildRays(glm::vec3 _intersectionPoint)
+void Sphere::calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint)				// TEMPORARY
 {
-	//Here we shall change the bool insideobject
-	//TODO: Write code
+	std::cout << "\nCalculating child ray for intersection point " << intersectionPoint.x << ", " << intersectionPoint.y << ", " << intersectionPoint.z << std::endl << std::endl;
+	// calculate direction for reflected or transmitted ray - WHITTED - (TEMPORARY)
+	std::cout << "====== Reflection/refraction =====" << std::endl;
+	glm::vec3 reflectedRayDirection = glm::reflect(_ray->getDirection(), intersectedNormal);
+	std::cout << "reflection = (" << reflectedRayDirection.x << ", " << reflectedRayDirection.y << ", " << reflectedRayDirection.z << ")" << std::endl;
+
+	glm::vec3 refractedRayDirection = glm::refract(_ray->getDirection(), intersectedNormal, refractiveIndex);
+	std::cout << "refraction = (" << refractedRayDirection.x << ", " << refractedRayDirection.y << ", " << refractedRayDirection.z << ")" << std::endl;
+
+	_ray->childNodes = new Ray(intersectionPoint, reflectedRayDirection, _ray->getImportance(), glm::vec3(0.0, 0.0, 0.0), false);
 }
 
 float Sphere::getRefractiveIndex()
diff --git a/CornellBox/src/Wall.cpp b/CornellBox/src/Wall.cpp
index b075812..32c292e 100644
--- a/CornellBox/src/Wall.cpp
+++ b/CornellBox/src/Wall.cpp
@@ -107,9 +107,16 @@ void Wall::initializeRectangles()
 	*/
 }
 
-void Wall::calculateChildRays(glm::vec3 _intersectionPoint)
+void Wall::calculateChildRays(Ray* _ray, glm::vec3 intersectionPoint)				// TEMPORARY
 {
+	// Russian Roulette
+	std::cout << "\nCalculating child ray for intersection point " << intersectionPoint.x << ", " << intersectionPoint.y << ", " << intersectionPoint.z << std::endl << std::endl;
+	// calculate direction for reflected or transmitted ray - WHITTED - (TEMPORARY)
+	std::cout << "====== Reflection/refraction =====" << std::endl;
+	glm::vec3 reflectedRayDirection = glm::reflect(_ray->getDirection(), intersectedNormal);
+	std::cout << "reflection = (" << reflectedRayDirection.x << ", " << reflectedRayDirection.y << ", " << reflectedRayDirection.z << ")" << std::endl;
 	
+	_ray->childNodes = new Ray(intersectionPoint, reflectedRayDirection, _ray->getImportance(), glm::vec3(0.0, 0.0, 0.0), false);
 }
 
 /* either one intersection or none (ray leaving) */				
diff --git a/CornellBox/src/main.cpp b/CornellBox/src/main.cpp
index e8f3560..55acaa3 100644
--- a/CornellBox/src/main.cpp
+++ b/CornellBox/src/main.cpp
@@ -48,7 +48,8 @@ int main(int argc, char *argv[])
 	// Sphere* sphereTransparent = new Sphere(positionSphereTransparent, radiusForSphereTransparent, transparencyForSphereTransparent, refractiveIndexForSphereTransparent);
 
 	// Create camera
-	Camera* camera = new Camera(room, eyeDistance, 4);
+	int raysPerPixel = 1;
+	Camera* camera = new Camera(room, eyeDistance, raysPerPixel);
 	
 	// Ray test
 	Ray* ray = new Ray(glm::vec3(2.5, 5.0, 2.5), glm::vec3(0.0, -1.0, 0.0), 1.0, glm::vec3(0.0, 0.0, 0.0), false);
